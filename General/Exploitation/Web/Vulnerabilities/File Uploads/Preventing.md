## Extension Validation
```php
$fileName = basename($_FILES["uploadFile"]["name"]);

// blacklist test
if (preg_match('/^.+\.ph(p|ps|ar|tml)/', $fileName)) {
    echo "Only images are allowed";
    die();
}

// whitelist test
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) {
    echo "Only images are allowed";
    die();
}
```
## Content Validation
```php
$fileName = basename($_FILES["uploadFile"]["name"]);
$contentType = $_FILES['uploadFile']['type'];
$MIMEtype = mime_content_type($_FILES['uploadFile']['tmp_name']);

// whitelist test
if (!preg_match('/^.*\.png$/', $fileName)) {
    echo "Only PNG images are allowed";
    die();
}

// content test
foreach (array($contentType, $MIMEtype) as $type) {
    if (!in_array($type, array('image/png'))) {
        echo "Only PNG images are allowed";
        die();
    }
}
```
## # Upload Disclosure Protection

To enhance security, avoid disclosing the uploads directory or granting direct access to uploaded files. Instead, hide the uploads directory from end-users and implement a **download page** for accessing files.

For example, a `download.php` script can be created to securely fetch and serve requested files. This setup hides the actual location of uploaded files, significantly reducing the risk of malicious code execution.

When using a download page, ensure the following:

1. **Access Control**: The `download.php` script should grant access only to files that belong to the requesting user, mitigating risks like IDOR (Insecure Direct Object References) or LFI (Local File Inclusion).
2. **403 Error for Directory Access**: Users should not directly access the uploads directory.
3. **HTTP Headers**: Use `Content-Disposition` and `nosniff` headers, and specify the correct `Content-Type` to enforce security.

### Additional Measures for Directory Security

- **Randomize Filenames**: Store uploaded files with randomized names while keeping sanitized original names in a database. When downloading, the original name is fetched from the database, ensuring that users don’t see the uploads directory or actual file names, which also helps prevent injection vulnerabilities.
- **Separate Storage for Uploaded Files**: Consider storing files on a separate server or container. In case of a remote code execution attack, only the uploads server would be compromised, protecting the main backend.
- **Restrict Directory Access**: Use configurations like PHP’s `open_basedir` to prevent web applications from accessing files outside permitted directories.

# Enhanced Security Measures

The above practices help reduce the risk of malicious file uploads and execution. However, additional steps can further strengthen server security if any primary controls are bypassed:

1. **Disable Dangerous PHP Functions**: Configure `php.ini` to disable functions like `exec`, `shell_exec`, `system`, and `passthru` that can execute system commands.
2. **Suppress System Errors**: Prevent sensitive information disclosure by handling errors at the application level with generic messages. Avoid showing specific details like file names or directory paths.

### Additional Recommendations

- **Limit File Size**: Set a maximum upload size to prevent large, potentially malicious files.
- **Regularly Update Libraries**: Keep all dependencies up-to-date to prevent vulnerabilities.
- **Scan Files for Malware**: Use automated scans to detect and block malicious content.
- **Implement a Web Application Firewall (WAF)**: A WAF provides an extra layer of defense against suspicious file uploads.

By following these practices, your application should be well-protected against common file upload threats. These points also serve as a useful checklist during web penetration testing to ensure security gaps are addressed.
